# 第九章 I2C介绍及使用

> 📌 **本章目标**：深入掌握 RA6E2 的 **I2C（Inter-Integrated Circuit）模块配置、主从模式、多设备通信、DMA传输、错误处理与典型外设驱动（如EEPROM、传感器）**，构建稳定可靠的 I2C 总线系统。

---

## 1. RA6E2 I2C 模块简介

RA6E2 内置多个 **I2C 通道（如 I2C0~I2C3）**，支持主从双模式，符合标准 I2C 协议（最高 400 kbps），部分通道支持 **FM+ 模式（1 Mbps）**。

### 1.1 I2C 核心特性

| 特性         | 说明                                           |
| ---------- | -------------------------------------------- |
| 工作模式       | 主模式（Master）、从模式（Slave）                       |
| 时钟频率       | 标准模式：100 kbps，快速模式：400 kbps，FM+：1 Mbps（部分通道） |
| 地址模式       | 7位地址（主流），支持10位地址（高级）                         |
| 数据缓冲       | 支持发送/接收 FIFO（提高效率）                           |
| 中断支持       | 传输完成、总线错误、地址匹配等中断                            |
| DMA/DTC 支持 | ✅ 支持 DTC 自动收发，降低 CPU 负担                      |
| SMBus 支持   | ✅ 支持 SMBus 2.0 协议（用于电源管理设备）                  |
| 低功耗        | 可在待机模式下通过 I2C 唤醒（若配置为从机）                     |

📌 **典型应用场景**：

- 读写 EEPROM（如 24C02）
- 连接传感器（如 BME280、MPU6050）
- 配置 PMIC（电源管理芯片）
- 多 MCU 通信
- 扩展 GPIO（通过 I2C GPIO Expander）

---

## 2. I2C 协议基础回顾

### 2.1 信号线

- **SDA**：数据线（双向）
- **SCL**：时钟线（主控）

### 2.2 通信流程

```c
Start → [Slave Address + R/W] → ACK → Data Bytes → ACK → ... → Stop
```

### 2.3 7位地址格式

- 实际发送：`[7位地址 << 1] | R/W_bit`
- 例如：设备地址 `0x50`，写操作 → `0xA0`，读操作 → `0xA1`

---

## 3. FSP 图形化配置 I2C（主模式）

### 3.1 添加 I2C 模块

1. 打开 `FSP Configuration` → `Threads` → `hal_entry` → 点击 `+`
2. 选择 `Driver` → `Connectivity` → `I2C`（注意不是 SCI 的 I2C 模式）
3. 添加 `g_i2c_master`（如 `g_i2c0`）

---

### 3.2 配置主模式参数（Properties）

| 参数               | 推荐值/说明                                  |
| ---------------- | --------------------------------------- |
| **Channel**      | 0, 1, 2, 3（选择 I2C0）                     |
| **Mode**         | `Master`                                |
| **Bit Rate**     | `Standard (100kbps)` 或 `Fast (400kbps)` |
| **Own Address**  | 不设置（主机无需地址）                             |
| **Clock Source** | PCLKB（建议 ≥ 40MHz）                       |
| **DTC Support**  | ✅ Enable（用于大数据收发）                       |

---

### 3.3 配置引脚（Pins 标签页）

- `I2C0 SCL` → 分配到物理引脚（如 P402）
- `I2C0 SDA` → 分配到物理引脚（如 P403）
- Mode: `Peripheral` → Peripheral: `I2C0_SCL`, `I2C0_SDA`
- Output Type: `Open-drain`
- Pull-up: ✅ Enable（或外接 4.7kΩ 上拉电阻）

> ✅ RA6E2 内部有弱上拉，但**建议外接上拉电阻**以确保稳定性。

---

### 3.4 配置 DTC（可选，DMA 级传输）

1. 添加 `DTC` 模块
2. 在 I2C 配置中：
   - `Use DTC for Transmit`: ✅
   - `Use DTC for Receive`: ✅
   - 设置 DTC 通道

> ✅ 启用 DTC 后，`R_I2C_Read`/`Write` 自动使用 DMA 传输！

---

## 4. I2C 相关 FSP 函数详解

> 📌 所有函数声明在 `r_i2c_master.h` 中（主模式）。

---

### 4.1 R_I2C_MasterOpen

#### 4.1.1 函数原型及功能

初始化 I2C 主机。

```c
fsp_err_t R_I2C_MasterOpen(i2c_master_ctrl_t * const p_ctrl, i2c_master_cfg_t const * const p_cfg)
```

#### 4.1.2 参数

- `i2c_master_ctrl_t * const p_ctrl`：控制句柄（如 `g_i2c0_ctrl`）
- `i2c_master_cfg_t const * const p_cfg`：配置结构体（如 `g_i2c0_cfg`）

#### 4.1.3 返回值

- `FSP_SUCCESS`：成功
- `FSP_ERR_ASSERTION`
- `FSP_ERR_ALREADY_OPEN`
- `FSP_ERR_INVALID_ARGUMENT`

📌 **典型用法**：

```c
fsp_err_t err = R_I2C_MasterOpen(&g_i2c0_ctrl, &g_i2c0_cfg);
if (FSP_SUCCESS != err) while(1);
```

---

### 4.2 R_I2C_MasterWrite

#### 4.2.1 函数原型及功能

向 I2C 从设备写入数据。

```c
fsp_err_t R_I2C_MasterWrite(i2c_master_ctrl_t * const p_ctrl, uint8_t * const p_src, uint32_t const bytes, uint8_t const slave_addr)
```

#### 4.2.2 参数

- `p_src`：要发送的数据缓冲区
- `bytes`：数据字节数
- `slave_addr`：从设备 7 位地址（如 `0x50` for 24C02）

📌 **通信流程**：

```c
Start → [slave_addr << 1 | 0] → ACK → p_src[0] → ... → p_src[n] → Stop
```

---

### 4.3 R_I2C_MasterRead

#### 4.3.1 函数原型及功能

从 I2C 从设备读取数据。

```c
fsp_err_t R_I2C_MasterRead(i2c_master_ctrl_t * const p_ctrl, uint8_t * const p_dest, uint32_t const bytes, uint8_t const slave_addr)
```

#### 4.3.2 参数

- `p_dest`：接收缓冲区
- `bytes`：期望读取字节数
- `slave_addr`：从设备 7 位地址

📌 **通信流程**：

```c
Start → [slave_addr << 1 | 1] → ACK → p_dest[0] ← ... ← p_dest[n] ← Stop
```

---

### 4.4 R_I2C_MasterAbort

#### 4.4.1 函数原型及功能

中止当前 I2C 传输。

```c
fsp_err_t R_I2C_MasterAbort(i2c_master_ctrl_t * const p_ctrl)
```

---

### 4.5 R_I2C_MasterClose

#### 4.5.1 函数原型及功能

关闭 I2C 模块。

```c
fsp_err_t R_I2C_MasterClose(i2c_master_ctrl_t * const p_ctrl)
```

---

### 4.6 R_I2C_MasterStatusGet

#### 4.6.1 函数原型及功能

查询 I2C 当前状态。

```c
fsp_err_t R_I2C_MasterStatusGet(i2c_master_ctrl_t * const p_ctrl, i2c_master_status_t * const p_status)
```

---

## 5. I2C 中断回调函数

```c
void i2c_callback(i2c_master_callback_args_t *p_args)
{
    switch(p_args->event)
    {
        case I2C_MASTER_EVENT_TX_COMPLETE:
            // 写操作完成
            g_i2c_tx_done = true;
            break;

        case I2C_MASTER_EVENT_RX_COMPLETE:
            // 读操作完成
            g_i2c_rx_done = true;
            break;

        case I2C_MASTER_EVENT_ABORTED:
            // 传输中止
            break;

        case I2C_MASTER_EVENT_TIMEOUT:
        case I2C_MASTER_EVENT_BUS_ERROR:
            // 总线错误，需复位
            R_I2C_MasterReset(&g_i2c0_ctrl);
            break;

        default:
            break;
    }
}
```

---

## 6. 实战1：读写 24C02 EEPROM

### 6.1 24C02 通信协议

- 设备地址：`0x50`（A2A1A0=000）
- 写流程：
  1. 发送设备地址 + 写位
  2. 发送内存地址（1字节）
  3. 发送数据
- 读流程：
  1. 发送设备地址 + 写位 → 发送内存地址
  2. 重启（Repeated Start）
  3. 发送设备地址 + 读位 → 接收数据

### 6.2 代码实现

```c
#include "hal_data.h"

#define EEPROM_ADDR 0x50
#define MEM_ADDR    0x00

void write_eeprom(uint8_t data)
{
    uint8_t tx_buf[2] = {MEM_ADDR, data};
    R_I2C_MasterWrite(&g_i2c0_ctrl, tx_buf, 2, EEPROM_ADDR);
    // 等待写完成（约 5ms）
    R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MILLISECONDS);
}

uint8_t read_eeprom(void)
{
    uint8_t data;
    // 先发送地址
    R_I2C_MasterWrite(&g_i2c0_ctrl, &MEM_ADDR, 1, EEPROM_ADDR);
    // 重启并读取
    R_I2C_MasterRead(&g_i2c0_ctrl, &data, 1, EEPROM_ADDR);
    return data;
}

void hal_entry(void)
{
    R_I2C_MasterOpen(&g_i2c0_ctrl, &g_i2c0_cfg);

    uint8_t val = 0;

    while(1)
    {
        write_eeprom(val);
        R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
        uint8_t read_val = read_eeprom();
        val++;

        char msg[32];
        snprintf(msg, sizeof(msg), "Write: %d, Read: %d\r\n", val-1, read_val);
        R_SCI_UART_Write(&g_uart0_ctrl, (uint8_t*)msg, strlen(msg));

        R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
    }
}
```

---

## 7. 实战2：读取 BME280 传感器数据

### 7.1 BME280 寄存器访问

- 设备地址：`0x76` 或 `0x77`（看 SDO 引脚）
- 读取温度/湿度：从 `0xFA` 开始读 8 字节

```c
uint8_t read_bme280(void)
{
    uint8_t reg = 0xFA; // 温湿度数据起始地址
    uint8_t data[8];

    // 设置寄存器地址
    R_I2C_MasterWrite(&g_i2c0_ctrl, &reg, 1, 0x77);
    // 读取数据
    R_I2C_MasterRead(&g_i2c0_ctrl, data, 8, 0x77);

    // 解析数据（略，需调用 BME280 库）
    return data[0];
}
```

---

## 8. I2C 错误处理与恢复

| 错误事件            | 原因              | 恢复策略            |
| --------------- | --------------- | --------------- |
| `BUS_ERROR`     | SDA/SCL 被拉低无法释放 | 软件复位 I2C 模块     |
| `TIMEOUT`       | 设备无响应           | 检查接线、地址、电源      |
| `NACK_RECEIVED` | 从机未应答           | 重试 2~3 次，仍失败则报错 |
| `ABORTED`       | 主动中止或冲突         | 重新初始化           |

📌 **建议封装重试机制**：

```c

```

---

## 9. I2C 函数速查表

| 函数名                     | 用途      | 关键参数                      | 返回值/错误码           | 注意事项         |
| ----------------------- | ------- | ------------------------- | ----------------- | ------------ |
| `R_I2C_MasterOpen`      | 初始化I2C主 | `p_ctrl`, `p_cfg`         | `ALREADY_OPEN`    | 必须最先调用       |
| `R_I2C_MasterWrite`     | 写数据到从设备 | `p_src`, `bytes`, `addr`  | `NACK`, `TIMEOUT` | 非阻塞，用回调通知完成  |
| `R_I2C_MasterRead`      | 从从设备读数据 | `p_dest`, `bytes`, `addr` | `NACK`, `TIMEOUT` | 读前需先写地址（若需要） |
| `R_I2C_MasterAbort`     | 中止传输    | -                         | -                 | 紧急停止         |
| `R_I2C_MasterStatusGet` | 查询状态    | `*p_status`               | -                 | 轮询时使用        |
| `R_I2C_MasterReset`     | 复位模块    | -                         | -                 | 错误后调用        |
| `i2c_callback`          | 事件回调    | `p_args->event`           | 无返回值              | 处理完成/错误事件    |

---

## 10. 开发建议

✅ **推荐做法**：

1. **始终外接 4.7kΩ 上拉电阻**（提高总线稳定性）
2. **使用回调机制**，避免阻塞
3. **关键操作添加重试机制**
4. **长距离布线时降低波特率**（如 100kbps）
5. **多设备时注意地址冲突**

⛔ **避免做法**：

1. **忽略 NACK 错误**（可能导致总线挂死）
2. **在中断中执行 I2C 通信**（除非你完全控制时序）
3. **使用过长的 I2C 线缆**（>30cm 建议加缓冲器）

---


